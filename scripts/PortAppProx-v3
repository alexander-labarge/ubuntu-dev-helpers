#!/bin/bash

set -Eeuo pipefail
shopt -s inherit_errexit

# Exit codes for granular error handling
readonly EXIT_SUCCESS=0
readonly EXIT_MISSING_ARGS=1
readonly EXIT_PREREQ_FAILED=2
readonly EXIT_CLOUDFLARED_INSTALL_FAILED=3
readonly EXIT_AUTH_FAILED=4
readonly EXIT_TUNNEL_CREATE_FAILED=5
readonly EXIT_DNS_CONFIG_FAILED=6
readonly EXIT_SERVICE_CREATE_FAILED=7
readonly EXIT_SERVICE_START_FAILED=8
readonly EXIT_VERIFICATION_FAILED=9

# Default Variables
TUNNEL_NAME=""
FQ_DNS_RECORD=""
SUBDOMAIN=""
IP_ADDRESS=""
PORT=""
UNNATTENDED=false
DNS_PROPAGATION_WAIT=30  # Increased from 10 to 30 seconds
CLEANUP_ON_ERROR=true
START_TEST_SERVER=false  # Don't start Python HTTP server by default

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
    --name)
        TUNNEL_NAME="$2"
        shift 2
        ;;
    --fqdn)
        FQ_DNS_RECORD="$2"
        shift 2
        ;;
    --hostname)
        SUBDOMAIN="$2"
        shift 2
        ;;
    --exposed-ip)
        IP_ADDRESS="$2"
        shift 2
        ;;
    --exposed-port)
        PORT="$2"
        shift 2
        ;;
    --unattended)
        UNNATTENDED=$2
        shift 2
        ;;
    --dns-wait)
        DNS_PROPAGATION_WAIT="$2"
        shift 2
        ;;
    --start-test-server)
        START_TEST_SERVER=true
        shift
        ;;
    *)
        echo "Unknown argument: $1"
        exit $EXIT_MISSING_ARGS
        ;;
    esac
done

# Color Constants
RESET='\033[0m'
FG_GREEN='\033[32m'
FG_YELLOW='\033[33m'
FG_RED='\033[31m'
FG_BLUE='\033[34m'
FG_CYAN='\033[36m'
FG_MAGENTA='\033[35m'
BOLD='\033[1m'
UNDERLINE='\033[4m'

# Ensure all required arguments are provided
if [[ -z "$TUNNEL_NAME" || -z "$FQ_DNS_RECORD" || -z "$SUBDOMAIN" || -z "$IP_ADDRESS" || -z "$PORT" ]]; then
    echo -e "${RESET}################################################################################\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}################################################################\033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}###################                          ###################\033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}##################     ${FG_RED}${BOLD} PortAppProx v3.0${RESET}${FG_BLUE}      ##################\033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}###################                          ###################\033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}################################################################\033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_YELLOW}${BOLD} Auto Service/Application Port Exposure System Service Generator \033[0m${RESET}#######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}################################################################\033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_MAGENTA}${BOLD} Purpose: ${FG_YELLOW}Completely automate the creation and management of a  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_MAGENTA} ${FG_YELLOW}${BOLD}Cloudflare tunnel with DNS mapping in less than 30 seconds.    \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_MAGENTA} ${FG_YELLOW}${BOLD}Deploy an app or 100's securely with minimal effort.           \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_MAGENTA}${BOLD} Overview:                                                      \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE} 1. Parses command-line arguments to get the tunnel name, fully \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    qualified domain name (FQDN), subdomain, IP address, port,  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    and an optional unattended flag.                            \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE} 2. Ensures that all required arguments are provided and checks \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    if ${FG_YELLOW}required tools (cloudflared, curl, python3)${RESET}${FG_BLUE} are installed.\033[0m${RESET}#######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    ${FG_YELLOW}(auto installs if missing)${RESET}${FG_BLUE}                                  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE} 3. Creates a Cloudflare tunnel using the provided tunnel name  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    and configures it to route traffic from the specified       \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    subdomain to the given IP address and port.                 \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE} 4. Sets up DNS records to map the subdomain to the Cloudflare  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    tunnel.                                                     \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE} 5. Creates a systemd service to manage the Cloudflare tunnel,  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    ensuring it starts on boot and can be easily managed.       \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE} 6. Provides an option to start a temporary Python HTTP server  \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}####### ${FG_BLUE}    for testing purposes.                                       \033[0m${RESET} #######\033[0m"

    echo -e "${RESET}################################################################################\033[0m"
    echo -e "${RESET}####### ┌───────────────────────────────────────────────────────────────┐#######\033[0m"
    echo -e "${RESET}####### │ \033[1;92mUSAGE:                                                       \033[0m${RESET} │#######\033[0m"
    echo -e "${RESET}####### │ \033[1;97m./PortAppProx-v3 --name <tunnel-name> --fqdn <fqdn> \033[0m${RESET}          │#######\033[0m"
    echo -e "${RESET}####### │ --hostname <hostname> --exposed-ip <ip> --exposed-port <port>\033[0m${RESET} │#######\033[0m"
    echo -e "${RESET}####### │ [--unattended true] [--dns-wait <seconds>]                  \033[0m${RESET}  │#######\033[0m"
    echo -e "${RESET}####### │ [--start-test-server]                                        \033[0m${RESET}  │#######\033[0m"
    echo -e "${RESET}####### └───────────────────────────────────────────────────────────────┘#######\033[0m"
    echo -e "${RESET}####### \033[1;92m  Optional Arguments:                                           \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}#######   --unattended true   Skip the prompt to keep the Python HTTP    #######\033[0m"
    echo -e "${RESET}#######                       server running in the background.          #######\033[0m"
    echo -e "${RESET}#######   --dns-wait <secs>   DNS propagation wait time (default: 30s)   #######\033[0m"
    echo -e "${RESET}#######   --start-test-server Start a Python HTTP test server for demo   #######\033[0m"
    echo -e "${RESET}#######                       (omit if you have your own app running)    #######\033[0m"
    echo -e "${RESET}################################################################################\033[0m"

    echo -e "${RESET}####### ┌───────────────────────────────────────────────────────────────┐#######\033[0m"
    echo -e "${RESET}####### │ \033[1;92mExample to Expose Gitlab on port 8080:                  \033[0m${RESET}      │#######\033[0m"
    echo -e "${RESET}####### │ \033[1;93m./PortAppProx-v3 --name gitlab                   \033[0m${RESET}             │#######\033[0m"
    echo -e "${RESET}####### │ --fqdn gitlab.example.org --hostname gitlab                  \033[0m${RESET} │#######\033[0m"
    echo -e "${RESET}####### │ --exposed-ip 127.0.0.1 --exposed-port 8080                   \033[0m${RESET} │#######\033[0m"
    echo -e "${RESET}####### │ --unattended true --dns-wait 60                              \033[0m${RESET} │#######\033[0m"
    echo -e "${RESET}####### └───────────────────────────────────────────────────────────────┘#######\033[0m"
    echo -e "${RESET}################################################################################\033[0m"

    echo -e "${RESET}####### \033[1;96mThese settings would initialize:                                \033[0m${RESET} #######\033[0m"
    echo -e "${RESET}################################################################################\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Tunnel Name ${RESET}                   : gitlab                          #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Tunnel ID${RESET}                      : 4acfe8b0-048f-43b3-81aa-c9e3114 #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Fully Qualified Domain Name${RESET}    : gitlab.example.org              #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Access Link${RESET}                    : https://gitlab.example.org      #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Systemd Service File${RESET}           : /etc/systemd/system/cloudflared #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Systemd Service Status${RESET}         : active                          #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}IPv4 Routing Info${RESET}              : 192.168.50.61 as source for IPv4#######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}IPv6 Routing Info${RESET}              : fd6d:5ffe:b8b6:f43:a582:bc3f:a7 #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Tunnel Config YAML${RESET}             : /home/skywalker/.cloudflared/te #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Tunnel Credentials JSON${RESET}        : /home/skywalker/.cloudflared/te #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Cloudflare Certificate${RESET}         : /home/skywalker/.cloudflared/ce #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}Exposed Usable Port${RESET}            : 8080                            #######\033[0m"
    echo -e "${RESET}####### ${FG_CYAN}The Port Serves${RESET}                : https://gitlab.example.org      #######\033[0m"
    echo -e "${RESET}################################################################################\033[0m"
    echo -e "\033[0m"

    exit $EXIT_MISSING_ARGS
fi

CURRENT_USER=$(whoami)
HOME_DIR=$(eval echo "~$CURRENT_USER")
WORKING_DIR="$HOME_DIR/$TUNNEL_NAME"
CLOUDFLARED_DIR="$HOME_DIR/.cloudflared"
TUNNEL_CONFIG_FILE="$CLOUDFLARED_DIR/${TUNNEL_NAME}.yml"
TUNNEL_CRED_FILE="$CLOUDFLARED_DIR/${TUNNEL_NAME}.json"
SYSTEMD_SERVICE_FILE="/etc/systemd/system/cloudflared-${TUNNEL_NAME}.service"
LOG_DIR="$WORKING_DIR/logs"
LOG_FILE="$LOG_DIR/${TUNNEL_NAME}_$(date +'%Y%m%d_%H%M%S').creation.log"
MAX_LOG_SIZE=10485760  # 10 MB in bytes
MAX_LOG_FILES=5

# Utility Functions
timestamp() {
    date +"%Y-%m-%d %H:%M:%S"
}

rotate_logs() {
    if [ ! -d "$LOG_DIR" ]; then
        return
    fi
    
    # Check if current log file exceeds max size
    if [ -f "$LOG_FILE" ] && [ $(stat -c%s "$LOG_FILE" 2>/dev/null || stat -f%z "$LOG_FILE" 2>/dev/null) -gt $MAX_LOG_SIZE ]; then
        local rotated_log="${LOG_FILE}.$(date +'%Y%m%d_%H%M%S')"
        mv "$LOG_FILE" "$rotated_log"
        gzip "$rotated_log" 2>/dev/null || true
    fi
    
    # Remove old log files, keeping only MAX_LOG_FILES
    local log_count=$(find "$LOG_DIR" -name "${TUNNEL_NAME}_*.creation.log*" -type f | wc -l)
    if [ $log_count -gt $MAX_LOG_FILES ]; then
        find "$LOG_DIR" -name "${TUNNEL_NAME}_*.creation.log*" -type f -printf '%T+ %p\n' | sort | head -n -$MAX_LOG_FILES | cut -d' ' -f2- | xargs rm -f
    fi
}

log() {
    local type=$1 message=$2 color_type color_time="${FG_GREEN}" color_message="${FG_YELLOW}" time_stamp
    time_stamp=$(timestamp)

    case "$type" in
    "ERROR") color_type="${FG_RED}" ;;
    "SUCCESS") color_type="${FG_GREEN}" ;;
    "INFO") color_type="${FG_CYAN}" ;;
    "WARN") color_type="${FG_YELLOW}" ;;
    *) color_type="${RESET}" ;;
    esac

    # Display on console
    echo -e "${BOLD}${color_time}$(timestamp)${RESET} ${BOLD}${color_type}[$type]${RESET} ${color_message}${message}${RESET}"

    # Ensure log directory exists before writing
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR" 2>/dev/null || true
    fi

    # Log to file with rotation check
    if [ -d "$LOG_DIR" ]; then
        rotate_logs
        echo "$(timestamp) [$type] $message" >>"$LOG_FILE"
    fi
}

print_separator() {
    echo -e "${FG_BLUE}────────────────────────────────────────────────────────────────────────────────${RESET}"
}

cleanup_on_failure() {
    if [ "$CLEANUP_ON_ERROR" = true ] && [ "$START_TEST_SERVER" = true ]; then
        log "WARN" "Cleaning up due to failure..."
        cleanup_temp_server
    fi
}

cleanup_temp_server() {
    log "INFO" "Cleaning up Python HTTP server..."
    
    if [ -f "$WORKING_DIR/http_server.pid" ]; then
        HTTP_SERVER_PID=$(cat "$WORKING_DIR/http_server.pid")
        if kill -0 $HTTP_SERVER_PID 2>/dev/null; then
            kill $HTTP_SERVER_PID
            log "INFO" "Python HTTP server stopped."
        fi
        rm -f "$WORKING_DIR/http_server.pid"
    fi
    
    # Also try to kill by port if PID method fails
    sudo lsof -ti:$PORT 2>/dev/null | xargs -r sudo kill -9 2>/dev/null || true
}

ensure_working_directory() {
    log "INFO" "Setting up the working directory..."
    mkdir -p "$WORKING_DIR"
    mkdir -p "$LOG_DIR"
    mkdir -p "$CLOUDFLARED_DIR"
    log "INFO" "Working directory: $WORKING_DIR"
}

check_prerequisites() {
    # Check if user is root and warn if they are
    if [ "$EUID" -eq 0 ]; then
        log "WARN" "Script is running as root. Consider running as a regular user with sudo privileges."
    fi

    # Check for required tools
    local missing_tools=()
    local required_tools=(curl systemctl)
    
    # Only require python3 if test server will be started
    if [ "$START_TEST_SERVER" = true ]; then
        required_tools+=(python3)
    fi
    
    for tool in "${required_tools[@]}"; do
        if ! command -v "$tool" &>/dev/null; then
            missing_tools+=("$tool")
        fi
    done

    if [ ${#missing_tools[@]} -gt 0 ]; then
        log "INFO" "Installing missing tools: ${missing_tools[*]}"
        if ! sudo apt-get update; then
            log "ERROR" "Failed to update package list"
            exit $EXIT_PREREQ_FAILED
        fi
        if ! sudo apt-get install -y "${missing_tools[@]}"; then
            log "ERROR" "Failed to install required tools"
            exit $EXIT_PREREQ_FAILED
        fi
    fi
}

install_cloudflared() {
    if command -v cloudflared &>/dev/null; then
        log "INFO" "cloudflared is already installed."
        return
    fi

    log "INFO" "Installing cloudflared..."
    if ! curl -L --output /tmp/cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb; then
        log "ERROR" "Failed to download cloudflared"
        exit $EXIT_CLOUDFLARED_INSTALL_FAILED
    fi
    
    if ! sudo dpkg -i /tmp/cloudflared.deb; then
        log "ERROR" "Failed to install cloudflared"
        rm /tmp/cloudflared.deb
        exit $EXIT_CLOUDFLARED_INSTALL_FAILED
    fi
    
    rm /tmp/cloudflared.deb
    log "SUCCESS" "cloudflared installed successfully."
}

authenticate_cloudflared() {
    if [ ! -f "$CLOUDFLARED_DIR/cert.pem" ]; then
        log "INFO" "No certificate found. Authenticating with Cloudflare..."
        if ! cloudflared tunnel login; then
            log "ERROR" "Failed to authenticate with Cloudflare"
            exit $EXIT_AUTH_FAILED
        fi
        log "SUCCESS" "Authentication complete."
    else
        log "INFO" "Cloudflare certificate already exists."
    fi
}

delete_existing_tunnel() {
    # Check if tunnel exists
    if cloudflared tunnel list 2>/dev/null | grep -q "$TUNNEL_NAME"; then
        log "WARN" "Tunnel '$TUNNEL_NAME' already exists."
        
        # First, try to cleanup any active connections
        log "INFO" "Cleaning up any active tunnel connections..."
        cloudflared tunnel cleanup "$TUNNEL_NAME" >>"$LOG_FILE" 2>&1 || true
        sleep 2
        
        log "INFO" "Deleting existing tunnel..."
        
        # Use set +e to handle potential failures gracefully
        # Note: --force must come BEFORE the tunnel name
        set +e
        local delete_output
        delete_output=$(cloudflared tunnel delete --force "$TUNNEL_NAME" 2>&1)
        local delete_status=$?
        set -e
        
        echo "$delete_output" >>"$LOG_FILE"
        
        if [ $delete_status -ne 0 ]; then
            log "WARN" "First delete attempt failed: $delete_output"
            log "INFO" "Waiting and retrying tunnel deletion..."
            sleep 3
            
            # Try cleanup again
            cloudflared tunnel cleanup "$TUNNEL_NAME" >>"$LOG_FILE" 2>&1 || true
            sleep 2
            
            set +e
            delete_output=$(cloudflared tunnel delete --force "$TUNNEL_NAME" 2>&1)
            delete_status=$?
            set -e
            
            if [ $delete_status -ne 0 ]; then
                log "ERROR" "Failed to delete tunnel after retry: $delete_output"
                exit $EXIT_TUNNEL_CREATE_FAILED
            fi
        fi
        
        log "INFO" "Existing tunnel deleted."
    fi

    # Clean up existing config files
    if [ -f "$TUNNEL_CONFIG_FILE" ]; then
        rm -f "$TUNNEL_CONFIG_FILE"
        log "INFO" "Removed existing tunnel config file."
    fi

    if [ -f "$TUNNEL_CRED_FILE" ]; then
        rm -f "$TUNNEL_CRED_FILE"
        log "INFO" "Removed existing credential file."
    fi
}

create_tunnel() {
    log "INFO" "Creating new tunnel '$TUNNEL_NAME'..."
    
    # Temporarily disable errexit to capture command output and exit code
    set +e
    TUNNEL_OUTPUT=$(cloudflared tunnel create "$TUNNEL_NAME" 2>&1)
    local create_status=$?
    set -e
    
    if [ $create_status -ne 0 ]; then
        log "ERROR" "Failed to create tunnel: $TUNNEL_OUTPUT"
        exit $EXIT_TUNNEL_CREATE_FAILED
    fi
    
    echo "$TUNNEL_OUTPUT" >>"$LOG_FILE"

    # Extract tunnel ID from output
    TUNNEL_ID=$(echo "$TUNNEL_OUTPUT" | grep -oP '[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}' | head -1)

    if [ -z "$TUNNEL_ID" ]; then
        log "ERROR" "Failed to extract tunnel ID from output"
        exit $EXIT_TUNNEL_CREATE_FAILED
    fi

    log "SUCCESS" "Tunnel created with ID: $TUNNEL_ID"
}

ensure_credentials_file() {
    # The credential file should have been created when tunnel was created
    # It's usually at ~/.cloudflared/<tunnel-id>.json
    local expected_cred_file="$CLOUDFLARED_DIR/${TUNNEL_ID}.json"

    if [ -f "$expected_cred_file" ]; then
        # Copy to our expected location
        cp "$expected_cred_file" "$TUNNEL_CRED_FILE"
        log "SUCCESS" "Credentials file found and copied."
    else
        log "ERROR" "Credentials file not found at $expected_cred_file"
        exit $EXIT_TUNNEL_CREATE_FAILED
    fi
}

create_yaml_config() {
    log "INFO" "Creating tunnel configuration..."
    cat >"$TUNNEL_CONFIG_FILE" <<EOF
tunnel: $TUNNEL_ID
credentials-file: $TUNNEL_CRED_FILE

ingress:
  - hostname: $FQ_DNS_RECORD
    service: http://$IP_ADDRESS:$PORT
  - service: http_status:404
EOF
    log "SUCCESS" "Tunnel configuration created at $TUNNEL_CONFIG_FILE"
}

map_dns_routes() {
    log "INFO" "Setting up DNS routes..."
    
    set +e
    local dns_output
    dns_output=$(cloudflared tunnel route dns "$TUNNEL_NAME" "$FQ_DNS_RECORD" 2>&1)
    local dns_status=$?
    set -e
    
    echo "$dns_output" >>"$LOG_FILE"
    
    # Check if it failed but the error is just "already exists" which is okay
    if [ $dns_status -ne 0 ]; then
        if echo "$dns_output" | grep -qi "already exists"; then
            log "INFO" "DNS route already exists for $FQ_DNS_RECORD - continuing"
        else
            log "ERROR" "Failed to configure DNS routes: $dns_output"
            exit $EXIT_DNS_CONFIG_FAILED
        fi
    else
        log "SUCCESS" "DNS routes configured for $FQ_DNS_RECORD"
    fi
}

create_systemd_service() {
    log "INFO" "Creating systemd service file..."
    
    if ! sudo tee "$SYSTEMD_SERVICE_FILE" >/dev/null <<EOF
[Unit]
Description=Cloudflare Tunnel for $TUNNEL_NAME
After=network-online.target
Wants=network-online.target
StartLimitInterval=0

[Service]
Type=notify
ExecStart=/usr/bin/cloudflared --no-autoupdate tunnel --config $TUNNEL_CONFIG_FILE run
Restart=on-failure
RestartSec=5
User=$CURRENT_USER
Group=$CURRENT_USER
WorkingDirectory=$HOME_DIR
Environment="HOME=$HOME_DIR"

# Resource limits
LimitNOFILE=65536
LimitNPROC=4096

# Security hardening
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ProtectHome=read-only
ReadWritePaths=$CLOUDFLARED_DIR $WORKING_DIR

# Logging
StandardOutput=journal
StandardError=journal
SyslogIdentifier=cloudflared-$TUNNEL_NAME

[Install]
WantedBy=multi-user.target
EOF
    then
        log "ERROR" "Failed to create systemd service file"
        exit $EXIT_SERVICE_CREATE_FAILED
    fi
    
    # Reload systemd to recognize the new service
    if ! sudo systemctl daemon-reload; then
        log "ERROR" "Failed to reload systemd daemon"
        exit $EXIT_SERVICE_CREATE_FAILED
    fi
    
    # Enable the service to start on boot
    if ! sudo systemctl enable "cloudflared-${TUNNEL_NAME}.service" >>"$LOG_FILE" 2>&1; then
        log "ERROR" "Failed to enable systemd service"
        exit $EXIT_SERVICE_CREATE_FAILED
    fi
    
    log "SUCCESS" "Systemd service file created and enabled."
}

start_tunnel_service() {
    log "INFO" "Starting the tunnel service..."
    
    # Ensure any existing instance is stopped
    sudo systemctl stop "cloudflared-${TUNNEL_NAME}.service" 2>/dev/null || true
    
    # Start the service
    if ! sudo systemctl start "cloudflared-${TUNNEL_NAME}.service"; then
        log "ERROR" "Failed to start the tunnel service"
        sudo journalctl -u "cloudflared-${TUNNEL_NAME}.service" -n 50 --no-pager >>"$LOG_FILE" 2>&1
        exit $EXIT_SERVICE_START_FAILED
    fi
    
    # Wait a bit for service to stabilize
    sleep 5
    
    # Check if service started successfully
    if sudo systemctl is-active --quiet "cloudflared-${TUNNEL_NAME}.service"; then
        log "SUCCESS" "Tunnel service 'cloudflared-${TUNNEL_NAME}.service' started successfully."
        
        # Show service status for debugging
        sudo systemctl status "cloudflared-${TUNNEL_NAME}.service" --no-pager >>"$LOG_FILE" 2>&1
    else
        log "ERROR" "Failed to start the tunnel service. Check logs with: sudo journalctl -u cloudflared-${TUNNEL_NAME}.service"
        
        # Show recent logs for debugging
        sudo journalctl -u "cloudflared-${TUNNEL_NAME}.service" -n 50 --no-pager >>"$LOG_FILE" 2>&1
        exit $EXIT_SERVICE_START_FAILED
    fi
}

start_python_http_server() {
    cd "$WORKING_DIR"
    log "INFO" "Starting temporary Python HTTP server on port $PORT..."
    
    # Kill any existing processes on this port
    local pids=$(sudo lsof -ti:$PORT 2>/dev/null)
    if [ -n "$pids" ]; then
        log "WARN" "Port $PORT is in use by PIDs: $pids. Killing them..."
        echo "$pids" | xargs -r sudo kill -9 2>/dev/null || true
        sleep 2
    fi
    
    # Start the HTTP server
    nohup python3 -m http.server "$PORT" --bind "$IP_ADDRESS" >"$WORKING_DIR/http_server.log" 2>&1 &
    HTTP_SERVER_PID=$!
    
    # Wait a moment and verify it started
    sleep 2
    if kill -0 $HTTP_SERVER_PID 2>/dev/null; then
        echo $HTTP_SERVER_PID > "$WORKING_DIR/http_server.pid"
        log "SUCCESS" "Python HTTP server started with PID $HTTP_SERVER_PID"
    else
        log "ERROR" "Failed to start Python HTTP server. Check $WORKING_DIR/http_server.log"
        if [ -f "$WORKING_DIR/http_server.log" ]; then
            cat "$WORKING_DIR/http_server.log" | tail -20 >>"$LOG_FILE"
        fi
        exit $EXIT_SERVICE_START_FAILED
    fi
}

verify_tunnel_with_curl() {
    log "INFO" "Waiting for tunnel to be fully established and DNS to propagate (${DNS_PROPAGATION_WAIT}s)..."
    
    # Show progress during wait
    for i in $(seq 1 $DNS_PROPAGATION_WAIT); do
        sleep 1
        if [ $((i % 10)) -eq 0 ]; then
            log "INFO" "Still waiting... ${i}/${DNS_PROPAGATION_WAIT}s elapsed"
        fi
    done
    
    log "INFO" "Using curl to verify the tunnel at 'https://$FQ_DNS_RECORD'..."

    # Disable errexit for curl verification since connection failures are expected
    set +e
    
    # Fetch the HTTP response headers and body
    curl_output=$(curl -s -w "\nHTTP_STATUS:%{http_code}" --connect-timeout 30 --max-time 60 "https://$FQ_DNS_RECORD" 2>&1)
    local curl_status=$?
    
    set -e

    # Extract the HTTP status code
    http_status=$(echo "$curl_output" | grep "HTTP_STATUS" | awk -F: '{print $2}')

    # Separate the body from the status code
    response_body=$(echo "$curl_output" | sed -n '1,/^HTTP_STATUS:/p' | sed '$d')

    # Log the response body
    echo "$response_body" >>"$LOG_FILE"

    # Check if curl itself failed (network error)
    if [ $curl_status -ne 0 ] && [ -z "$http_status" ]; then
        log "WARN" "Curl failed with exit code $curl_status - tunnel might still be establishing..."
        log "INFO" "You can verify manually at: https://$FQ_DNS_RECORD"
        print_success_message
        return
    fi

    # Check if the HTTP request was successful
    if [ -n "$http_status" ] && { [ "$http_status" -eq 200 ] || [ "$http_status" -eq 301 ] || [ "$http_status" -eq 302 ]; }; then
        log "SUCCESS" "Tunnel verified successfully. HTTP Status: $http_status"
        print_success_message
    else
        log "WARN" "HTTP Status: ${http_status:-unknown} - Tunnel might still be establishing..."
        log "INFO" "You can verify manually at: https://$FQ_DNS_RECORD"
        print_success_message
    fi
}

print_success_message() {
    local systemd_check_active=$(systemctl show --property=ActiveState "cloudflared-${TUNNEL_NAME}.service" | cut -d'=' -f2)
    
    # Extract the routing information with better error handling
    local systemd_check_ipv4_route_default="N/A"
    local systemd_check_ipv6_route_default="N/A"
    
    if sudo systemctl status "cloudflared-${TUNNEL_NAME}.service" --no-pager 2>/dev/null | grep -q "proxy will use"; then
        systemd_check_ipv4_route_default=$(sudo systemctl status "cloudflared-${TUNNEL_NAME}.service" --no-pager 2>/dev/null | grep -i "ipv4" | sed 's/^.*proxy will use //' | head -1)
        systemd_check_ipv6_route_default=$(sudo systemctl status "cloudflared-${TUNNEL_NAME}.service" --no-pager 2>/dev/null | grep -i "ipv6" | sed 's/^.*proxy will use //' | head -1)
    fi
    
    print_separator
    echo -e "${FG_BLUE}${BOLD} Tunnel Setup Successful! ${RESET}"
    print_separator
    echo -e "${FG_GREEN}${BOLD}Systemd Service Info:${RESET}"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Systemd Service File" "$SYSTEMD_SERVICE_FILE"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Systemd Service Status" "$systemd_check_active"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "IPv4 Routing Info" "${systemd_check_ipv4_route_default:-N/A}"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "IPv6 Routing Info" "${systemd_check_ipv6_route_default:-N/A}"
    print_separator
    echo -e "${FG_GREEN}${BOLD}Tunnel Info:${RESET}"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Tunnel FQDN" "$FQ_DNS_RECORD"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Tunnel Name" "$TUNNEL_NAME"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Tunnel ID" "$TUNNEL_ID"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Tunnel Config YAML" "$TUNNEL_CONFIG_FILE"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Tunnel Credentials JSON" "$TUNNEL_CRED_FILE"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Cloudflare Certificate" "$CLOUDFLARED_DIR/cert.pem"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Log Directory" "$LOG_DIR"
    print_separator
    echo -e "${FG_GREEN}${BOLD}Connection Info:${RESET}"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "Exposed Usable Port" "$PORT"
    printf "${FG_CYAN}${BOLD}%-30s : ${FG_YELLOW}%s${RESET}\n" "The Port Serves" "https://$FQ_DNS_RECORD"
    print_separator
    echo -e "${FG_GREEN}${BOLD}Useful Commands:${RESET}"
    echo -e "  View logs:    ${FG_YELLOW}sudo journalctl -u cloudflared-${TUNNEL_NAME}.service -f${RESET}"
    echo -e "  Restart:      ${FG_YELLOW}sudo systemctl restart cloudflared-${TUNNEL_NAME}.service${RESET}"
    echo -e "  Stop:         ${FG_YELLOW}sudo systemctl stop cloudflared-${TUNNEL_NAME}.service${RESET}"
    echo -e "  Status:       ${FG_YELLOW}sudo systemctl status cloudflared-${TUNNEL_NAME}.service${RESET}"
    print_separator
}

delete_existing_service() {
    if [ -f "$SYSTEMD_SERVICE_FILE" ]; then
        log "WARN" "Service file '$SYSTEMD_SERVICE_FILE' already exists."
        
        # Stop the service if it's running
        if sudo systemctl is-active --quiet "cloudflared-${TUNNEL_NAME}.service"; then
            log "INFO" "Stopping existing service 'cloudflared-${TUNNEL_NAME}.service'..."
            sudo systemctl stop "cloudflared-${TUNNEL_NAME}.service"
            log "INFO" "Service stopped."
        fi
        
        # Disable the service
        log "INFO" "Disabling existing service..."
        sudo systemctl disable "cloudflared-${TUNNEL_NAME}.service" >>"$LOG_FILE" 2>&1 || true
        
        # Remove the service file
        sudo rm -f "$SYSTEMD_SERVICE_FILE"
        
        # Reload systemd daemon
        sudo systemctl daemon-reload
        
        log "INFO" "Service removed and systemd reloaded."
    else
        log "INFO" "No existing service file found."
    fi
}

prompt_keep_server_running() {
    # Mark that we've successfully completed - don't cleanup temp server on exit
    CLEANUP_ON_ERROR=false
    
    if [ "$UNNATTENDED" = true ]; then
        log "INFO" "Unattended mode: keeping the Python HTTP server running in the background."
        return
    fi
    
    while true; do
        read -p $'\e[1m\e[36mDo you want to keep the Python HTTP server running in the background? (yes/no):\e[0m ' choice
        case "$choice" in
        yes | y | Y | Yes | YES)
            log "INFO" "Keeping the Python HTTP server running in the background."
            break
            ;;
        no | n | N | No | NO)
            cleanup_temp_server
            break
            ;;
        *)
            echo -e "${FG_YELLOW}Please answer yes or no.${RESET}"
            ;;
        esac
    done
}

# Trap to handle errors and cleanup only on failure
trap 'cleanup_on_failure' ERR

# Main Execution
print_separator
log "INFO" "Starting PortAppProx v3.0 tunnel creation script..."
log "INFO" "DNS propagation wait time set to: ${DNS_PROPAGATION_WAIT} seconds"
ensure_working_directory
check_prerequisites
install_cloudflared
authenticate_cloudflared
delete_existing_tunnel
delete_existing_service
create_tunnel
ensure_credentials_file
create_yaml_config
map_dns_routes
create_systemd_service
start_tunnel_service

# Only start test server if flag is set
if [ "$START_TEST_SERVER" = true ]; then
    start_python_http_server
fi

verify_tunnel_with_curl

# Only prompt about server if we started one
if [ "$START_TEST_SERVER" = true ]; then
    prompt_keep_server_running
fi

log "SUCCESS" "Script completed successfully!"
exit $EXIT_SUCCESS