//! KVM management module
//! 
//! VirtualBox and KVM cannot run simultaneously as they both require exclusive
//! access to hardware virtualization (VT-x/AMD-V). This module manages KVM
//! kernel modules to allow VirtualBox to operate.

use crate::error::{Result, VBoxError};
use crate::utils::system;
use std::path::Path;

const BLACKLIST_FILE: &str = "/etc/modprobe.d/blacklist-kvm.conf";

/// KVM status information
#[derive(Debug, Clone)]
pub struct KvmStatus {
    pub kvm_loaded: bool,
    pub kvm_intel_loaded: bool,
    pub kvm_amd_loaded: bool,
    pub blacklisted: bool,
}

/// Check if KVM modules are loaded
pub fn check_kvm_status() -> Result<KvmStatus> {
    log::info!("Checking KVM status...");
    
    let kvm_loaded = system::is_module_loaded("kvm")?;
    let kvm_intel_loaded = system::is_module_loaded("kvm_intel")?;
    let kvm_amd_loaded = system::is_module_loaded("kvm_amd")?;
    let blacklisted = Path::new(BLACKLIST_FILE).exists();
    
    let status = KvmStatus {
        kvm_loaded,
        kvm_intel_loaded,
        kvm_amd_loaded,
        blacklisted,
    };
    
    log::debug!("KVM status: {:?}", status);
    Ok(status)
}

/// Check if hardware virtualization is supported
pub fn check_virtualization_support() -> Result<bool> {
    log::info!("Checking hardware virtualization support...");
    
    let cpuinfo = std::fs::read_to_string("/proc/cpuinfo")
        .map_err(|e| VBoxError::CommandFailed(format!("Failed to read /proc/cpuinfo: {}", e)))?;
    
    if cpuinfo.contains("vmx") {
        log::info!("Intel VT-x detected");
        Ok(true)
    } else if cpuinfo.contains("svm") {
        log::info!("AMD-V detected");
        Ok(true)
    } else {
        log::error!("No hardware virtualization support detected");
        Ok(false)
    }
}

/// Disable KVM modules temporarily (until reboot)
pub fn disable_kvm_temporary() -> Result<()> {
    system::check_root()?;
    log::info!("Disabling KVM modules temporarily (until reboot)...");
    
    let mut unloaded_any = false;
    
    // Unload in reverse order
    for module in ["kvm_intel", "kvm_amd", "kvm"].iter() {
        if system::is_module_loaded(module)? {
            log::info!("Unloading {} module...", module);
            system::unload_module(module)?;
            unloaded_any = true;
            log::info!("{} unloaded successfully", module);
        }
    }
    
    if unloaded_any {
        log::info!("KVM disabled successfully (until next reboot)");
        log::info!("VirtualBox can now be used");
        log::warn!("NOTE: This is temporary. KVM will reload on next boot.");
    } else {
        log::info!("KVM modules were not loaded");
    }
    
    Ok(())
}

/// Disable KVM modules permanently (survives reboot)
pub fn disable_kvm_permanent() -> Result<()> {
    system::check_root()?;
    log::info!("Disabling KVM permanently (survives reboot)...");
    
    // First disable temporarily
    disable_kvm_temporary()?;
    
    // Create blacklist file
    log::info!("Creating blacklist configuration...");
    
    let blacklist_content = "\
# Blacklist KVM modules to allow VirtualBox to operate
# VirtualBox and KVM cannot run simultaneously
# Generated by virtualbox-secure-boot-manager

blacklist kvm
blacklist kvm_intel
blacklist kvm_amd
";
    
    std::fs::write(BLACKLIST_FILE, blacklist_content)
        .map_err(|e| VBoxError::CommandFailed(format!("Failed to create blacklist file: {}", e)))?;
    
    log::info!("Blacklist file created: {}", BLACKLIST_FILE);
    
    // Update initramfs
    log::info!("Updating initramfs...");
    match system::execute_command_checked("update-initramfs", &["-u"]) {
        Ok(_) => log::info!("initramfs updated successfully"),
        Err(e) => log::warn!("Failed to update initramfs: {}", e),
    }
    
    log::info!("KVM disabled permanently");
    log::info!("Changes will take full effect after reboot");
    
    Ok(())
}

/// Re-enable KVM modules
pub fn enable_kvm() -> Result<()> {
    system::check_root()?;
    log::info!("Re-enabling KVM...");
    
    let mut changed = false;
    
    // Remove blacklist file if it exists
    if Path::new(BLACKLIST_FILE).exists() {
        log::info!("Removing blacklist file...");
        std::fs::remove_file(BLACKLIST_FILE)
            .map_err(|e| VBoxError::CommandFailed(format!("Failed to remove blacklist: {}", e)))?;
        log::info!("Blacklist file removed");
        changed = true;
        
        // Update initramfs
        log::info!("Updating initramfs...");
        match system::execute_command_checked("update-initramfs", &["-u"]) {
            Ok(_) => log::info!("initramfs updated successfully"),
            Err(e) => log::warn!("Failed to update initramfs: {}", e),
        }
    }
    
    // Try to load KVM modules
    log::info!("Loading KVM modules...");
    
    let cpuinfo = std::fs::read_to_string("/proc/cpuinfo")
        .map_err(|e| VBoxError::CommandFailed(format!("Failed to read /proc/cpuinfo: {}", e)))?;
    
    if cpuinfo.contains("vmx") {
        // Intel
        match system::load_module("kvm_intel") {
            Ok(_) => {
                log::info!("kvm_intel loaded successfully");
                changed = true;
            }
            Err(e) => log::warn!("Could not load kvm_intel (may need reboot): {}", e),
        }
    } else if cpuinfo.contains("svm") {
        // AMD
        match system::load_module("kvm_amd") {
            Ok(_) => {
                log::info!("kvm_amd loaded successfully");
                changed = true;
            }
            Err(e) => log::warn!("Could not load kvm_amd (may need reboot): {}", e),
        }
    }
    
    if changed {
        log::info!("KVM re-enabled");
        log::warn!("VirtualBox will NO LONGER work until KVM is disabled again");
        log::info!("You may need to reboot for all changes to take effect");
    } else {
        log::info!("KVM was not disabled");
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_check_virtualization_support() {
        let result = check_virtualization_support();
        // This test may fail on systems without virtualization
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_check_kvm_status() {
        let result = check_kvm_status();
        assert!(result.is_ok());
    }
}
